# Group Theory Classes
# TODO:  Make this much more abstract and formal.
'''
This is a class library meant to explore group theory, specifically cyclic groups;  And even more specifically, additive and mulitiplicative groups of integers modulo some number.
It is also meant to explore ways of quickly generating new multiplicative sequences from generators that already have an index, both in terms of computational complexity and overall computer resources.

Generating an additive sequence using the index of the multiplicative generator as the generator gives a sequence of indices that can be used to iterate over the corresponding multiplicative
group, creating the new mulitiplicative sequence.  This technique requires 'n' additive steps and indexing steps instead of multiplicative steps.  This is quite significant because, depending on the
implementation, a multiplicative step requires b/2 addition operations, where 'b' is the bitsize, for a discrete random variable.  Each addition operation is on average 1.5 times as expensive in the 
multiplicative steps as well.  This is usually the case when using standard multiplication provided by the instuction set, usually  denoted 'mul', and implemented by the processor or by microcode.
'''

import num_theory

gcd = num_theory.euclid_algo
factor = num_theory.factor

class CyclicGroup:
	""" Base Class for all Cyclic Groups """
	
	def __init__ (self):
		""" Class initialiser """
		pass
		
	def identity(self):
		""" Returns the identity element of the group."""
		pass
		
	def __len__(self):
		""" Returns the length of the underling set which is also the order of the group."""
		return len(self.G)

	def __lt__(self, rhs) -> bool:
		""" Returns true if this group is a proper subgroup of 'rhs'. 
		This re-implements the '<' operator that represents the proper subset operator when applied to sets."""
		return self.n == rhs.n and len(rhs) % len(self.G) == 0 and len(self.G) < len(rhs)
	
	def __le__(self, rhs) -> bool:
		""" Returns true if this group is an improper subgroup of 'rhs'. 
		This re-implements the '<=' operator that represents the improper subset operator when applied to sets."""
		return self.is_subgroup(rhs)
		
	def is_subgroup(self, rhs = None) -> bool:
		if rhs is None: return self.order() < self.n
		else: return self.n == rhs.n and len(rhs) % len(self.G) == 0 and len(self.G) <= len(rhs)
	
	def order(self) -> int:
		""" Order of the group.
		This is length of the underlying set and is the same as calling __len__(x) or len(this)."""
		return len(self.G)
		
	def is_generator(self, g: int, o: int = None) -> bool:
		return g in self.genset
		
	def op(self, lhs, rhs):
		""" The operator of the group.  This function performs the binary operation of the group on 'lhs' and 'rhs'."""
		# TODO:  Perform a speed test on this compared to using the built in operator.  Or see if that information exists.
		pass 
		
	def pow(self, b, p):
		""" Raises 'b' to the 'p' power.  Note that this means to perform the operation of the group given by 'self.op(...)' on the base, 'b', 'p' times;
		As opposed to exponentiation, the multiplicative power, which is what raising something to the power of means in elementary arithmetic.
		For example, the additive power is multiplication and the multiplicative power is exponentiaton."""
		pass 

	def op_elem(self, lhs, rhs):
		""" The elementary operator that corresponds to the operator of the group, given by 'self.op(...)'.  This function performs the _elementary_ binary operation of the group on 'lhs' and 'rhs'. 
		Example:  If the method 'self.op(...)' performs modular arithmetic addition, this method will perform elementary arithmetic addition. """
		pass

	def sequence(self, g: int) -> list:
		""" Returns a sequence generated by 'g'.  Sometimes known as the cyclic subgroup of 'g'."""
		# TODO:  Look into making this a warning instead of an error.
		if self.is_generator(g) == False: raise ValueError(f'{g:d} is not a generator of this group.')
		# Check if a sequence has already been generated by 'g'.
		if g in self.seq.keys(): return self.seq[g]
		# Cyclic subgroup of 'g' not found.  One must be generated.
		if self.order() + self.identity() == self.n:
			# Is the cyclic group, 'Cn', where 'n' is the modulus of this group.
			self.seq[g] = [self.identity()]
			x = g
			for i in range(1, self.order()):
				self.seq[g].append(x)
				x = self.op(x, g)
		else:
			# Is a proper subgroup of the cyclic group, 'Cn', where 'n' is the modulus of this group.
			self.seq[g] = [self.pow(g, i) for i in range(self.order())]
		return self.seq[g]
		
	def quotients (self, g: int) -> dict:
		""" Returns two associative sequences generated by 'g' in a dictionary.  This function is similar to 'CyclicGroup.sequence(...)', but returns a sequence of quotients and remainders
		instead of just a sequence of remainders. """
		res = {'q': [], 'r': []}
		# TODO:  Look into making this a warning instead of an error.
		if self.is_generator(g) == False: raise ValueError(f'{g:d} is not a generator of this group.')
		if self.order() + self.identity() == self.n:
			# Is the cyclic group, 'Cn', where 'n' is the modulus of this group.
			res['r'].append(self.identity())
			res['q'].append(0)
			q, r = divmod(g, self.n)
			for i in range(1, self.order()):
				res['q'].append(q); res['r'].append(r)
				q, r = divmod(self.op_elem(r, g), self.n)				
		else:
			# Is a proper subgroup of the cyclic group, 'Cn', where 'n' is the modulus of this group.
			self.seq[g] = [self.pow(g, i) for i in range(self.order())]
		return res

	@property
	def generator(self):
		return self._generator

	@generator.setter
	def generator(self, g):
		if g not in self.genset: raise ValueError(f'Argument Value Error:\t{g} is not a generator of this cyclic group.')
		self._generator = g
		

class AdditiveGroup(CyclicGroup):
	""" Additive Group of Integers Modulo 'n'. """
	
	def __init__ (self, n, g: int = None):
		""" Initialize the group with a modulus of 'n'.  The underlying set does not need to be provided.  
		NOTE:  The argument passed to 'n' can be an integer or a dictionary of prime factors and powers, where the key is a prime factor and the value is it's prime power.
		Summary:
		The initial generator, 'g', is the identity element plus one by default.  A sequence is then generated for the underlying set.  A generator set is then created."""
		
		# Check argument type of the modulus, 'n'.
		if type(n) is int:
			self.n = n
			prime_facts = factor(n)
		elif type(n) is dict:
			self.n = 1
			for key, val in n.items(): self.n *= key**val
			prime_facts = n.copy()
		else:
			raise TypeError(f'An argument of type, {type(n)}, was passed to \'n\'.  Only python dictionaries and integers are supported.')
		
		# Check argument value of the generator, 'g'.
		if g is None: g = self.identity() + 1
		elif g % self.n <= self.identity(): g = self.identity() + 1
		else: g = g % self.n
		
		# A dictionary of sequences, denoted as 'self.seq', where the key is the generator and the value is the sequence.
		# Note: The generating set  can be found in the set of keys found in 'self.seq' and is every number in the group, 'G', that is coprime to 'n'.
		cur = self.identity()
		seq = [cur]
		for i in range(1, self.n):
			cur = self.op(cur, g)
			if cur == self.identity(): break
			seq.append(cur)
		self.seq = {g: seq}
		
		# The underlying set of the group.
		self.G = set(self.seq[g])
		
		# Calculate the prime factors and powers of the order, denoted as 'o', which divides 'n' in the case of Zn/Z; or the Carmichael number of 'n' in the case of Zn/Z^X.
		o = self.__len__()
		if o != n and self.identity() == 0:
			prime_facts_order = dict()
			t = o
			for pf, pp in prime_facts.items():
				for i in range(pp):
					t, r = divmod(t, pf)
					if r == 0:
						if pf in prime_facts_order.keys(): prime_facts_order[pf] += 1
						else: prime_facts_order[pf] = 1
						if t == 1: break
					else:
						t = t * pf + r
						break
				if t == 1: break
		elif self.identity() == 1: prime_facts_order = factor(o)
		else: prime_facts_order = prime_facts.copy()
												
		
		# The indices of the elements in the generating set are given by the set below.  In the case of a additive non-subgroup, the set of indices is equal to the generating set.
		self.indices = set(num_theory.from_sieve(num_theory.coprime_sieve(set(prime_facts_order.keys()), o)))
		self.genset = {self.seq[g][i] for i in self.indices}

		# Set the generator intrinsic property.
		self._generator = g

	def modulus(self) -> int:
		""" The modulus of the group.  This is determined by the argument passed to the parameter,'n', in the class initializer method."""
		return self.n

	def identity(self) -> int:
		""" Returns the identity element of the additive groups of integers modulo 'n'."""
		return 0
			
	def op_elem(self, lhs, rhs) -> int:
		return lhs + rhs
		
	def op(self, lhs: int, rhs: int) -> int:
		""" The operator of the group.  This function performs the binary operation of the group, addition modulo 'n', on 'lhs' and 'rhs'.""" 
		return (lhs + rhs) % self.n
		
	def pow(self, b: int, p: int) -> int:
		""" Raises 'b' to the 'p' power.  Note that this means to perform the operation of the group given by 'self.op(...)' on the base, 'b', 'p' times;
		As opposed to exponentiation, the multiplicative power, which is what raising something to the power of means in elementary arithmetic.
		For example, the additive power is multiplication and the multiplicative power is exponentiaton."""
		return b*p % self.n
		
class MultiplicativeGroup(CyclicGroup):
	""" Multiplicative Group of Integers modulo 'n'."""
	
	__init__ = AdditiveGroup.__init__
		
	def identity(self) -> int:
		""" Returns the identity element of the Multiplicative groups of integers modulo 'n'."""
		return 1
		
	def op_elem(self, lhs, rhs) -> int:
		return lhs * rhs	
		
	def op(self, lhs: int, rhs: int) -> int:
		""" The operator of the group.  This function performs the binary operation of the group, multiplication modulo 'n', on 'lhs' and 'rhs'.""" 
		return (lhs * rhs) % self.n
		
	def pow(self, b: int, p: int) -> int:
		""" Raises 'b' to the 'p' power.  Note that this means to perform the operation of the group given by 'self.op(...)' on the base, 'b', 'p' times;
		As opposed to exponentiation, the multiplicative power, which is what raising something to the power of means in elementary arithmetic.
		For example, the additive power is multiplication and the multiplicative power is exponentiaton."""
		return num_theory.mod_exp(b, p, self.n)
